FTP - протокол передачи файлов по сети
построен на архитектуре клиент-сервер
Двойное подключение - передавать файлы в обоих направлениях
Встроеная аутентификация - получить доступ к FTP серверу по user/pass


Основные шаблоны проектирования:
Делегирование (Delegation pattern)  - сущность выражает поведение, но выполнение передает связанному объекту
Функциональный дизайн (Functional design) - 1-а сущность - 1-а обязанность и минимуи побочных эффектов на другие
Неизменяемый интерфейс (Immutable interface) - Создание неизменяемого объекта
- финал класс
- финал поля
- нет сеттеров
- клонирование объекта, возвращает глубокую копию
Интерфейс (Interface) - общий метод сущностей для взаимодействию в системе, простой доступ к другим классам
Интерфейс-маркер (Marker interface) - атрибут сообщает классу о предаставлении доступа на функционал
Контейнер свойств (Property container) - добавлять свойства в контейнер, вместо расширения новыми свойствами. Композиция Map 
Канал событий (Event channel) - создаёт общий канал для событий, подписчик может получать события от более чем одного издателя (Observer pattern)


Алгоритмы базовые концепции
Алгоритм - набор последовательности действий для решения задачи
Основные структуры данных
ArrayList - реализация интерфейса List с изменяемым размером массива, увеличить емкость ensureCapacity, что уменьшит объем дополнительного перераспределения
имеет емкость(сapacity), по мере добавления элементов в ArrayList его емкость автоматически увеличивается
LinkedList - состоит из Node(item,next,prev), реализация двусвязного списка интерфейсов List и Deque, реализация не синхронизирована, может содержать null
HashMap - cостоит Node(hash, key, value, Node), не синхронизирован и допускает значения null, не гарантирует, что порядок останется постоянным с течением времени,
реализация обеспечивает O(1) производительность основных операций(get, put) при условии, что хеш-функция правильно распределяет элементы по bucket-ам, 
если кол-во bucket больше 8 преобразуется в red-black tree(быстрый поиск)
имеет capacity(количество сегментов) и load factor(мера заполнения прежде чем емкость увеличиться) влияют на производительность
Stack - абстрактный тип данных, список элементов по принципу LIFO 
Queue - абстрактный тип данных, список элементов по принципу FIFO


модель памяти JVM 
Java Memory Model(JMM) - описывает поведение потоков в среде исполнения Java
набор правил, описывающий выполнение многопоточных программ и как потоки могут взаимодействовать посредством общей памяти
happens-before - определяет отношение между действиями посредством основной памяти
Основные области памяти:
Видимость (visibility)
регистры, локальные кеши, основная память
при входе в synchronized поток обновляет локальную память, при выходе из synchronized записывает изменения из локальной в общую
volatile - запись и чтение производится из общей памяти
final - неизменяемых (immutable) объекты могут свободно передаваться между потоками, без синхронизации
Reordering (переупорядочивание)
Для увеличения производительности процессор/компилятор могут переставлять местами некоторые инструкции/операции
volatile и synchronized(захват-освобождение монитора) - не могут быть переупорядочены


Аннотации
определяется @interface, предназначена для описания свойств и хранения метаданных, атрибут добавления функционала 
@Target(RUNTIME, ANNOTATION_TYPE) - указывает контексты, в которых применим интерфейс аннотаций. enum ElementType - места, где аннотации могут появляться в программе (TYPE, FIELD, METHOD, CONSTRUCTOR, PACKAGE, ...)
@Retention(RUNTIME, ANNOTATION_TYPE) - указывает, как долго должны храниться аннотации с аннотированным интерфейсом enum RetentionPolicy - политики сохранения аннотаций (SOURCE, CLASS, RUNTIME)
@Override(SOURCE, METHOD) - метод наследован от родительского класса
@Deprecated(RUNTIME, CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE) - устаревшие, будут убраны в последующих версиях
@SuppressWarnings(SOURCE, CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE) - отключает вывод предупреждений компилятора
@Documented(RUNTIME, ANNOTATION_TYPE) - javadoc, будет отображать в своих выходных данных


Интернационализация
помогает настроить Java-приложение для работы с разными языками, форматами чисел, валютами, региональным форматированием времени
final class Locale - для адаптации информации для использования DateTimeFormatter(withLocale), SimpleDateFormat, NumberFormat


Рефлексия(Reflection) Java
Механизм исследования данных о программе во время выполнения. Рефлексия позволяет исследовать информацию о полях, методах и конструкторах классов. 
class AccessibleObject - предоставляет возможность пометить отраженный объект как подавляющий проверки контроля доступа
Проверки доступа - для public, default, protected и private выполняются, когда поля, методы или конструкторы используются для установки или получения полей, для вызова методов или для создания и инициализации новых экземпляров классов
setAccessible(true) - true указывает, что отраженный объект должен подавлять проверку доступа


class Collections - состоит исключительно из статических методов, которые работают с коллекциями или возвращают их sort, shuffle, binarySearch, reverse
Properties - ключ-значение(строка-строка) в списке свойств, setProperty(String key, String value), thread-safe (потокобезопасный), properties.load(InputStream/Reader) читает проперти с .properties и .xml файлов
Comparable - накладывает порядок на объекты класса, который его реализует cравнивает этот объект с указанным объектом для последовательности - int compareTo(T o)
Сomparator - функция сравнения, накладывает порядок на коллекцию объектов, можно передать методу сортировки, сравнивает два аргумента в пользу порядка int compare(T o1, T o2)
если есть доступ к классу можем реализовать Comparable иначе можем передать Сomparator
Monitor - механизм управления одновременным доступом к объекту, реализуется synchronized - доступ в блок синхронизации имеет только 1 поток
Semaphore - позволяет определять кол-во потоков для доступа в блок синхронизации acquire() - получает разрешение от семафора и блокирует, release() - выдает разрешение, возвращая его семафору
Race condition - потоки получают доступ к общей памяти в неправильной последовательности
Deadlock - ошибка, происходит когда процессы имеют циклическую зависимость от пары синхронизированных объектов
Livelock - программы, активно выполняют параллельные операции, но эти операции никак не влияют на продвижение состояния программы вперед.
Starvation - ситуация, когда параллельный процесс не может получить все ресурсы, необходимые для выполнения его работы
class Thread - поток выполнения программы, 
@FunctionalInterface Runnable - run() операция не возвращает результат
@FunctionalInterface Callable - V call() - задача, которая возвращает результат и может вызвать исключение
synchronized - cоздает блок синхронизации на объекте для работы потоков (synchronized на метод, static метод (сlass), на объекте)
volatile - переменная которая записывается сразу в общую память


immutable and thread-safe:
Instant -  моделирует мгновенную точку на временной шкале возвращает сек. миллисек. наносек
Duration - моделирует количество между отрезками времени between(LocalDateTime, LocalDateTime)
Duration vs Period - Duration представляет меру измерения основанную на времени а Period на дате
LocalDate - представляет дату без time-zone
LocalTime - представляет время без time-zone
LocalDateTime - представляет дату-время без time-zone
ZonedDateTime - представляет дату-время с time-zone ZoneId, можно узнать currentStandardOffset от UTC
DateTimeFormatter - входной параметр в форматировании, и парсинге


Stream - Последовательность элементов, поддерживающих последовательные и параллельные различные операции над выборкой
Промежуточные (intermediate) - операции составляющие потоковый контейнер возвращает Stream filter, map, sorted
Терминальные (terminal) - заверщающая операция выполняет потоковый контейнер и выдает результат collect, forEach, findFirst, findAny
В Stream передаются lambda(@FunctionalInterface) выражения, реализованные lambda: R Function(T), boolean Predicate(T), void Consumer(T), R Supplier() и т.д.
если stream выполнил terminal операцию, повторные операции генерируют исключение



Batch Updates - пакетные обновления, позволяют обработать в виде пакета набор операторов обновления за раз
addBatch() - добавление запросов
executeBatch() - выполнение запросов
batchStatements - хранится ArrayList запросов (по дебагу)
batchParameters - ArrayList параметров для запросов (по дебагу)
после statement.executeBatch
batchStatements и batchParameters - пустые


File - абстрактное представление путей к файлам и каталогам и предаставляет основные методы для работы с файлами и директориями
InputStream - абстрактный класс является суперклассом всех классов, представляющих входной поток байтов
OutputStream - абстрактный класс является суперклассом всех классов, представляющих выходной поток байтов, принимает выходные байты и отправляет их в некоторый приемник
BufferedInputStream - добавляет возможность буферизации ввода при помощи буферного массива и поддержка методов пометки и сброса. Когда байты из потока считываются буфер пополняется.
FileInputStream - получает входные байты из файла в файловой системе, предназначен для чтения потоков байтов из файла
System.in - cтандартный поток ввода, соответствует вводу с клавиатуры или другому источнику ввода
System.out - cтандартный поток вывода соответствует выводу дисплея или другому месту назначения вывода
System.err - cтандартный поток вывода ошибок, используется для отображения сообщений об ошибках или другой информации


Path - объект, который можно использовать для поиска файла в файловой системе (получить File, кол-во элементов по Path(пути))
Files - класс состоит из статических методов, которые работают с файлами и каталогами, cоздание, чтение(byte, String), запись, копирование, перемещение файлов


Servlet API - API, для реализации на сервере и работе с клиентом по схеме запрос-ответ
Servlet - получают запросы от веб-клиентов и отвечают на них, обычно через HTTP. Реализация сlass extends HttpServlet @Override doGet,Post,Put,Delete
HttpServletRequest - запросить информацию для HTTP-сервлетов, 
HttpServletResponse - обеспечения специфичных для HTTP функций при отправке ответа. У него есть методы доступа к заголовкам HTTP и файлам cookie
в web.xml свойство loadonstartup 0 - запуск 1-ым сервлет вызов метода init 
ServletContextListener выполняется до запуска сервлета, настраивает контекст для всех сервлетов
фильры сервлета перехватывают запрос и перенаправляют на другой сервлет там обрабатывается и направялется дальше по цепочке
сервлет может обрабатывать несколько url
для создания фильтра implements Filter doFilter(request, response, filterChain), порядок выполнения фильтров как в web.xml
servlet lifecycle - загружается в tomcat(при запуске приложения) -> создается servlet instance -> init -> service -> destroy(при остановке приложения)
JSP(JavaServer Pages) - позволяет сгенерировать динамическое содержимое Web-страниц на стороне сервера
JSTL(JavaServer Pages Standard Tag Library) -  предоставляет теги JSP (цикл, условные выражения и т.д.)


Spring IoC - принцип ООП, основная задача передача ответственности за создание, составление, удаление объекта контейнеру, используется для уменьшения связанности между классами и объектами за счет внедрения зависимостей(DI)
DI - реализация IoC позволяет получать объект из контекста(контейнера) что позволяет использовать полиморфизм
Spring @Configuration - указывает, что класс объявил методы @Bean и может обрабатываться контейнером для генерации BeanDefinitions и запросов на обслуживание для этих компонентов во время выполнения
BeanPostProcessor - триггер, настраивает модификацию новых экземпляров bean-ов - проверку интерфейсов маркеров или обертывание bean в прокси
Spring MVC - модуль для реализации паттерна МVC (model, view, controller)
ModelAndView - данные передаются от клиента к серверу и наоборот
@ModelAttribute -  используем аннотацию с передаваемым параметром метода - указывает на получение модели от клиента
@Controller - обрабатывает запросы от клиета перенаправленные через DispatcherServlet
View - интерфейс рендеринг контента и представление модели 
ViewResolver - интерфейс, реализован объектами, которые возвращает(resolve) View по имени и локали(Locale)
Spring Rest - набор правил для построения веб-служб
@RestController - снабжена аннотациями @Controller и @ResponseBody - возвращаемое значение метода должно быть привязано к телу веб-ответа
Spring Data - модуль для работы со слоем данных
JDBC - (JdbcTemplate)упрощает использование JDBC, выполняет основной рабочий процесс, оставляя код приложения для предоставления SQL, перехватывая исключения, 
RowMapper - для сопоставления строк ResultSet c результирующим объектом
JPA(Java Persistence API) - возможность сохранять в удобном виде объекты в БД
ORM для работы с репозиторием Spring - hibernate реализация
СrudRepository (CRUD) -> JpaRepository (Sort, Pageable)
Sort - Возможность сортировки запросов, по пропертям
Page - позволяет получить подсписок списка объектов и положении его во всем списке
EntityManager(@PersistenceContext) - интерфейс для взаимодействия с набор уникальных сущностей аналог Session hibernate
EntityManagerFactory(@PersistenceUnit) - интерфейс для взаимодействия с набор классов связанных с БД
Persistence context - управляет набор уникальных сущностей с их жизненным циклом
Persistence unit - набор классов связанных с БД



Jakson - библиотека конвертация json-а в объекты и наоборот
ObjectMapper - предоставляет функциональные возможности для чтения/записи JSON либо в POJO, либо в модель дерева JSON (JsonNode), а также функции для преобразований writeValue, readValue, readTree
Ant - автоматизация сборки проектов, способ собрать war и расположить файлы приложения в tomcat (build.xml - для зборки)
<project> - сценарий(имя(name), цель(default)) минимум 1-а цель
<target> - цель(имя(name)) описываем задания(tasks(<java/c>, <copy>, <mkdir>, <jar>), возможность указывать зависимости(depends) cвязывают targets
ant <target_name> - запуск цели
Maven - автоматизация сборки проектов, на основе описания структуры в файлах POM(Project Object Model) (pom.xml - для зборки)
<project> - сценарий
<properties> - константы версий для dependency
<dependencies> - содержит <dependency>
<groupId> - уникальный id проекта (имена пакетов)
<artifactId> - имя jar без version
<version> - версия библиотеки
mvn clean - удаляет target directory
mvn compile - компилирует source code проекта
mvn package - собирает jar
Postman - приложение, позволяющее тестировать веб-API
Mercurial VCS - система управления версиями, помогает отслеживать изменения в программе
hg commit/rollback/push/update


Реляционные БД - бд в которой существуют отношение между таблицами в нормальной форме(совокупность требований для отношения)
1НФ - простые поля таблиц, нет повторений строк
2НФ - 1НФ и каждое поле таблицы зависит от PRIMARY KEY(PK) иначе вынести в отдельную таблицу
3НФ - 2НФ и поля таблиц не зависят друг от друга
4НФ - 3НФ и нет многозначная зависимость поля таблиц зависят от PK, но каждый раздельно
5НФ - 4НФ и отсутствуе зависимых соединений между полями таблиц
6НФ - 5НФ и дальнейшая композиция не может быть без потерь (1 поле таблицы с PK)
использует стандартный язык запросов SQL для хранения данных
NoSQL БД - использует документы JSON для хранения данных в виде(ключ-значение, матриц, документов(иерархических структур данных), графов)
Свойства БД(ACID) - набор требований к транзакционной системе обеспечивающий предсказуемую работу
атомарность -  транзакция не будет зафиксирована частично, либо выполнены все подоперации либо ни одной
согласованность - успешная транзакция фиксирует только допустимые результаты(ожидаемое поведение завершения транзакции)
изоляция - параллельные транзакции не должны оказывать влияния на результат работы транзакции
устойчивость - изменения сделанные успешно завершённой транзакцией не будут отменены
Уровни изоляций(Isolation Levels) - правила получения несогласованных данных после выполнения транзакций
Потерянное обновление (lost update) - проявляется при одновременном изменении одного блока данных разными транзакциями одно из изменений может теряться
READ UNCOMMITTED - чтение незафиксированных данных (может прочитать данные, которые будут rollback(«Грязное» чтение (dirty read))) решает lost update
READ COMMITTED - чтение фиксированных данных (не читает данные которые будут rollback, но в момент чтения другая транзакция может изменить читаемые данные)
REPEATABLE READ - другая транзакция не может изменять данные, читаемые текущей транзакцией, пока та не окончена, решает проблему
Неповторяющееся чтение (non-repeatable read) - при повторном чтении в рамках одной транзакции, ранее прочитанные данные, оказываются изменёнными
SERIALIZABLE - транзакции выполняются последовательно, решает проблему
Фантомное чтение (phantom reads) -  одни и те же выборки в транзакции дают разные множества строк


DDL(Data Definition Language) - язык описания данных для описания структуры БД (CREATE, ALTER, DROP)
DQL(Data query language) - для извлечения данных из БД (SELECT)
DML(Data manipulation language) - для получения, вставки, удаления или изменения данных в БД (INSERT, SELECT, UPDATE, DELETE)
DCL(Data control language) - для осуществления административных операций, присваивающих или отменяющих права (USAGE, GRANT, REVOKE)
TCL(Transaction control language) - набор команд, используемых для управления транзакциями (COMMIT, ROLLBACK)
Использование транзакций - ((BEGIN)BEGIN TRANSACTION, COMMIT(END TRANSACTION), ROLLBACK)
Использование сиквенсов - генератор последовательности для таблиц CREATE SEQUENCE NAME, NEXTVAL('NAME')
Использование ограничений - типы данных ограничивают множество данных CHECK(если не проходит CHECK - ошибка), NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, DELETE CASCADE
Использование группировок - группирует строки, объединяя в одну группу GROUP BY и фильтрует HAVING
Использование объединений - запросы могут обращаться к нескольким таблицам JOIN по предикату ON
Использование подзапросов - когда нужно использовать результат выполнения запроса в следующем запросе WHERE (SUBQUERY)
Использование встроенных функций - агрегатными(AVG, COUNT, MAX, MIN), строковые (CONCAT, LOWER), дата время (NOW) 
SQL injection - ввод обрабатывается как команда а не как данные
